# Verifiable Random Drawing System - Technical Documentation ðŸŽ²

## Overview

Our system uses a two-step approach (commit-reveal) to generate verifiable randomness on the blockchain without relying on external oracles.

## How it Works

### 1. Commit Phase (Deployment)
- A secret random number (reveal) is generated locally
- Its hash (commitHash) is calculated and stored in the contract
- The original reveal is securely saved locally

```solidity
// Generate reveal and commitHash
const reveal = ethers.randomBytes(32);
const commitHash = ethers.keccak256(reveal);
```

### 2. Reveal Phase (Drawing)
- The original reveal is provided at drawing time
- The contract verifies that its hash matches the stored commitHash
- The final random number is generated by combining:
  - The reveal
  - Block hash
  - Timestamp
  - Caller's address

## Benefits of this Approach

1. **Verifiable**: Anyone can verify that:
   - The reveal matches the initial commitHash
   - The drawing uses on-chain data

2. **Tamper-proof** because:
   - The reveal must match the initial hash
   - Block data is unpredictable
   - Drawing occurs at a defined future block

3. **Transparent**:
   - No external oracle
   - All data is on-chain
   - Fully verifiable process

## Verification Example

```solidity
// Verify reveal
require(keccak256(reveal) == commitHash, "Invalid reveal");

// Generate random seed
bytes32 randomSeed = keccak256(abi.encodePacked(
    reveal,
    blockhash(block.number - 1),
    block.timestamp,
    msg.sender
));
```
## Technical Implementation Details

### Random Seed Generation
The random seed combines multiple sources of entropy:
- Previous block hash
- Block timestamp
- Block prevrandao (Ethereum 2.0 randomness)
- Complete list of participants
- Reveal value
- Caller's address

### Winner Selection Algorithm
We use a modified Fisher-Yates shuffle to ensure:
- Fair distribution
- No duplicate winners
- Constant gas consumption

### Security Measures
1. **Time-lock mechanism**:
   - Drawing only possible after target block
   - Prevents early reveals

2. **Authorization system**:
   - Only authorized addresses can trigger drawing
   - Owner can manage authorized drawers

3. **Anti-manipulation**:
   - ReentrancyGuard protection
   - Pausable in case of emergency
   - Multiple entropy sources

## Security

1. **Manipulation Protection**:
   - Reveal must be provided within a specific timeframe
   - Uses previous block's hash
   - Multiple entropy sources combined

2. **Security Checks**:
   - Timing validation
   - Reveal verification
   - Authorization controls

## How to Verify a Drawing?

1. Retrieve drawing data:
   - Initial commitHash
   - Used reveal
   - Drawing block
   - Selected winners

2. Verify that:
   - `keccak256(reveal) == commitHash`
   - Drawing occurred at the correct block
   - Winner selection matches the generated seed

## Limitations and Considerations

- Requires secure storage of the reveal
- Drawing must occur within the defined time window
- System depends on the security of the underlying blockchain network
